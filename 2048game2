#include <iostream>
#include <vector>
using namespace std;

class node{
    public:
        int* matrix;
        int degree;

        node(){
            this.matrix = new int(n*n);
            this.degree = 0;
        }
}

void _copy(int* orgmatrix, int* matrix, int n){
    for(int i=0; i <n*n; i++){
        matrix[i] = orgmatrix[i];
    }
}

bool _isValid(int* matrix, int n, int limit, int db_size){
    int sum = 0;
    int valid_limit = limit;
    for(int i=0; i < 5 - db_size; i++) {
        if(valid_limit <= 2) break;
        valid_limit /= 2;
    }
    for(int i=0; i <n*n; i++){
        if(matrix[i] => valid_limit) sum += matrix[i];
    }
    if(sum >= limit) return true;
    else return false;
}

int _maxof(int* matrix, int n){
    int result = 0;
    for(int i=0; i <n*n; i++){
        if(matrix[i] > result) result = matrix[i];
    }
    return result;
}

void _doProgress(int* matrix, int n){
    vector<int> _stack;
    vector<int> _finalstack;
    for(int i=0; i < n; i++){
        for(int j=0; j < n; j++){
            if(matrix[i][j] == 0) continue;
            _stack.push_back(matrix[i][j]);
        }
        while(!_stack.empty()){
            if(!_finalstack.empty() && _finalstack.back() == _stack.at(0)){
                _finalstack.back() *= 2;
            }
            else _finalstack.push_back(_stack.at(0));
            _stack.erase(_stack.begin());
        }
        for(int j = 0; j < n; j++){
            if(_finalstack.empty()) {
                matrix[i][j] == 0;
                continue;
            }
            matrix[i][j] = _finalstack.at(0);
            _finalstack.erase(_finalstack.begin());
        }
    }
}

int main(){
    int n = 0;
    int db_size = 0;
    cin >> n;
    int* curr_matrix = new int (n*n);

    for(int i=0; i < n*n; i++) cin >> curr_matrix[i];

    node* db = new node[5];

    db[0].matrix = new int(n*n);
    _copy(db[0], curr_matrix, n);

    int limit = _maxof(curr_matrix) * 2; //극복해야 할 숫자

    bool flag = true;

    while(flag){
        if(_isValid(curr_matrix, n, limit, db_size)){
            if(db_size >= 3){ //이번에 만지고 있는게 index 4짜리 그러니까 5번째 거
                if(_maxof(curr_matrix) >= limit) limit = _maxof(curr_matrix);
            }
            else{
                _copy(curr_matrix ,db[++db_size].matrix, n); // 원래 거 저장하고
                _doProgress(curr_matrix); // 기능 실행
            }
        }
        else{
            if(db[db_size]
        }
    }

}
